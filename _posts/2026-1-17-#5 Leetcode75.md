1768. 交替合并字符串

给你两个字符串 `word1` 和 `word2` 。请你从 `word1` 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。
返回 **合并后的字符串** 。

 **示例 1：**

```
输入：word1 = "abc", word2 = "pqr"
输出："apbqcr"
解释：字符串合并情况如下所示：
word1：  a   b   c
word2：    p   q   r
合并后：  a p b q c r
```

**示例 2：**

```
输入：word1 = "ab", word2 = "pqrs"
输出："apbqrs"
解释：注意，word2 比 word1 长，"rs" 需要追加到合并后字符串的末尾。
word1：  a   b 
word2：    p   q   r   s
合并后：  a p b q   r   s
```

**示例 3：**

```
输入：word1 = "abcd", word2 = "pq"
输出："apbqcd"
解释：注意，word1 比 word2 长，"cd" 需要追加到合并后字符串的末尾。
word1：  a   b   c   d
word2：    p   q 
合并后：  a p b q c   d
```

**提示：**

- `1 <= word1.length, word2.length <= 100`
- `word1` 和 `word2` 由小写英文字母组成

```c++
#include <iostream>
#include <string>

class MergeAlternately {
public:
    std::string mergeAlternately(std::string word1, std::string word2) {
		std::string newWord;

		//方法1：（失败）
		//while (i < word1.length())
		//{
		//	newWord.append(*(word1 + i)); // 这里不能+i 是因为std::string不能当成指针来使用 尽管它内部确实是字符数组
		//	newWord.append(*(word2 + i));
		//}

		//方法2：（我的做法 只能说是勉强能用）
		int i = 0;
		for (char c1 : word1)
		{
			// 应该是newWord.append(1, c1);  1表示添加1个c1 而不是 newWord.append(c1);
			// 但还是选择了下面的operator+=方式
			newWord += c1;
			if (i < word2.length())
				newWord += word2[i];
			i++;
		}

		for (; i < word2.length(); i++)
			newWord += word2[i];

		//更优雅的方法3：（双指针）
		//int i = 0, j = 0;
		//while (i < word1.size() || j < word2.size()) {
		//	if (i < word1.size()) {
		//		newWord += word1[i++];
		//	}
		//	if (j < word2.size()) {
		//		newWord += word2[j++];
		//	}
		//}

        return newWord;
    }
};
```

