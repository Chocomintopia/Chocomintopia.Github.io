[文字实录](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5OTc1NjI5Ng==&action=getalbum&album_id=2583276961356152834&subscene=126&scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5OTc1NjI5Ng%3D%3D%26mid%3D2247484131%26idx%3D1%26sn%3D285efe80781d4eaa9e9371854f4ee379%26chksm%3Dc04f3a84f738b392e3d83da1c3dd81fbe04b293a7934367482ee91565319c942a8faade58930%26scene%3D126%26sessionid%3D0%26subscene%3D7%26clicktime%3D1758523086%26enterid%3D1758523086%26ascene%3D3%26devicetype%3DiOS18.5%26version%3D18003f2d%26nettype%3DWIFI%26abtest_cookie%3DAAACAA%253D%253D%26lang%3Dzh_CN%26fontScale%3D129%26exportkey%3Dn_ChQIAhIQTOQHnOKyRyj2WS1kAknTiBLfAQIE97dBBAEAAAAAAAbRMN%252Fkd5kAAAAOpnltbLcz9gKNyK89dVj05tXuOV9YNWyorw1BFbAlsDiHInvkKNQde9U7Myl9OMgQN%252F%252BEnuHI5HVqJdOK8%252FUuLap52zK1xzUfsKTigjT6cLbpruOlbiUHdpqKm691LBICKeKDLhv5m%252BlYqvmlYz7ZJw%252BDJz5LfQ79SgOV8tUO0QFuLMBnMa2S91sgB6eIRFoktyd5wkGCd6VHRkF8EDJ05TuNGLFxmYYDVPMqLJ4hEyO5Jvx6EA83A8pcKiFihJM0P%252FM7eqCLJ7w%253D%26pass_ticket%3DKcHmv5ftBq7a%252F%252Bq3RAqPBhCL7C%252FNjK%252BRy3aBiFHrYeQ9Nzf0AIzjIcu0m9TbflRX%26wx_header%3D3&nolastread=1#wechat_redirect)

# 如何构建游戏世界

本来觉得写一个类就可以同时拥有游戏对象 game object简称GO的属性和方法 如果想要添加更多功能 就由这个类去派上一个子类 但是很多时候功能是混合的 可能有某个类是结合了两个基类的功能 这没有办法靠继承解决 也没有办法通过写比这两个基类更基础的类来解决 因为如果总是去做更简化的话 最终就会不再具有类的特征
现代引擎的解决办法是组件化 把对象拆分成行为和属性 拆分成无数的组件 这样再通过组件的组合 就可以变成无数多种不同的东西
比如有一个无人机 他在空间上的位置 我们就将它形成一个组件叫transform 表示他在空间的各个位置占用关系 他的外形也制作一个组件叫model 组件health就是血量 那么现在只要写一个组件的基类 其他组件都从这个基类派生 component base

tick 才能让时间向前行进起来 时间是离散地前进着 每个不同GO里相同的组件一起tick 这才叫工业中的流水线批处理 pipeline
tick分为tick render渲染和tick logic逻辑

event机制 一个炮弹要炸了 实际上它会给周围的物体一个通知 你们应该炸了 你们自己看着自己应该受多少伤害 就自己处理吧 反正大家都很真诚 不会假装自己不受伤 解耦合 把各个机构之间的通讯 让它们自行处理 就没有必要知道其它component到底怎么回事

每一个GO都有自己的编号 但是如果一次性通知所有的GO 就太多了 所以要把整个场景划分成格子 然后再去找到物体 但是物体终究是分配不均的 这时候希望用层级结构来解决

![1.png](../images/3/1.png)

思想类似于 把整个世界分成国家 国家分成省 省分成市 那么如果有任意一件事件发生 比如北京海淀区的某一条大街发生的事情 我只需要在北京海淀区寻找

八叉树 oct tree 但是现代游戏引擎比较流行的是BVH bounding box 空间中的数据管理是场景管理的核心 如果物体是动态的 需要更新 那么就相当于做了树的插入和删除操作 如果做游戏引擎的话 要支持2-3种不同的空间划分算法 交给产品自己去选择

所有的物体都是一个object 每一个object都是用component base去描述它 用component组合出物体的不同行为 所有的component 都是用tick的方法 不断地tick它各自的逻辑 往前走 GO之间是靠复杂的消息机制来进行通信 这么多物体在管理的时候需要一个高效的层次结构的场景管理机制

比如在游戏里开车 就发生了角色与车的绑定 车在动 人的位移是被车锁定的 这样tick就有先后关系 一般会要求父节点 父GO会先tick 然后挂在上面的东西在后面tick 这样人去tick时 就会先问 我的车在哪里 发现车已经往前移动了30cm 那好吧我也往前移动30cm

但是实际场景中的tick**时序**会更加复杂 当我们去tick一个component的时候 是要分散到很多CPU上去并行执行的 而并行执行的时序是非常重要的 GO之间的通讯如果是彼此直接通过event机制互相通信 但是这很容易造成逻辑上的混乱 发生循环依赖 就比如你给女友写信 说我们分手吧 她同时也给你写信说分手 这样就会根本搞不懂是谁先甩了谁 我们希望用户进行相同的输入时 游戏里会发生的行为一定是具有确定性的 一样的输入一定跑出一样的结果 这时候就需要引入一个第三方 再去分发 这样就能确保时序是严格一致的 实践中有pre-trick和post-tick

# 渲染

