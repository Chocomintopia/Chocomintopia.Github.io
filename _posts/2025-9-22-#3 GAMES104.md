平台层 核心层 资源层 功能层 工具层

本来觉得写一个类就可以同时拥有游戏对象game object简称GO的属性和方法 如果想要添加更多功能 就由这个类去派上一个子类 但是很多时候功能是混合的 可能有某个类是结合了两个基类的功能 这没有办法靠继承解决 也没有办法通过写比这两个基类更基础的类来解决 因为如果总是去做更简化的话 最终就会不再具有类的特征
现代引擎的解决办法是组件化 把对象拆分成行为和属性 拆分成无数的组件 这样再通过组件的组合 就可以变成无数多种不同的东西
比如有一个无人机 他在空间上的位置 我们就将它形成一个组件叫transform 表示他在空间的各个位置占用关系 他的外形也制作一个组件叫model 组件health就是血量 那么现在只要写一个组件的基类 其他组件都从这个基类派生 component base

tick 才能让时间向前行进起来 时间是离散地前进着 每个不同GO里相同的组件一起tick 这才叫工业中的流水线批处理 pipeline

event机制 一个炮弹要炸了 实际上它会给周围的物体一个通知 你们应该炸了 你们自己看着自己应该受多少伤害 就自己处理吧 反正大家都很真诚 不会假装自己不受伤 解耦合 把各个机构之间的通讯 让它们自行处理 就没有必要知道其它component到底怎么回事

每一个GO都有自己的编号 但是如果一次性通知所有的GO 就太多了 所以要把整个场景划分成格子 然后再去找到物体 但是物体终究是分配不均的 这时候希望用层级结构来解决